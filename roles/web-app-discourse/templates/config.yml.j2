templates:
{% if not lookup('database', application_id, 'shared')%}
  - "templates/postgres.template.yml"
{% endif %}
  #- "templates/redis.template.yml"
  - "templates/web.template.yml"
  ## Uncomment the next line to enable the IPv6 listener
  #- "templates/web.ipv6.template.yml"
  - "templates/web.ratelimited.template.yml"
  ## Uncomment these two lines if you wish to add Lets Encrypt (https)
  #- "templates/web.ssl.template.yml"
  #- "templates/web.letsencrypt.ssl.template.yml"

## which TCP/IP ports should this container expose?
## If you want Discourse to share a port with another webserver like Apache or nginx,
## see https://meta.discourse.org/t/17247 for details
expose:
  - "{{ DOCKER_BIND_HOST }}:{{ ports.localhost.http[application_id] }}:80"   # http

params:
  db_default_text_search_config: "pg_catalog.english"

  ## Set db_shared_buffers to a max of 25% of the total memory.
  ## will be set automatically by bootstrap based on detected RAM, or you can override
  db_shared_buffers: "4096MB"

  ## can improve sorting performance, but adds memory usage per-connection
  #db_work_mem: "40MB"

  ## Which Git revision should this container use? (default: tests-passed)
  #version: tests-passed

env:
  LC_ALL:   "{{ DISCOURSE_LOCAL }}"
  LANG:     "{{ DISCOURSE_LOCAL }}"
  LANGUAGE: "{{ DISCOURSE_LOCAL }}"
  #DISCOURSE_DEFAULT_LOCALE: {{ HOST_LL }} # Deactivated because not right format was selected @todo find right format

  DB_POOL:            "{{ POSTGRES_ALLOWED_AVG_CONNECTIONS }}"
  RAILS_MAX_THREADS:  "{{ [ (POSTGRES_ALLOWED_AVG_CONNECTIONS | int), 5 ] | min }}"
  UNICORN_WORKERS:    "{{ [ (POSTGRES_ALLOWED_AVG_CONNECTIONS | int) // 2, 1 ] | max }}"


  ## How many concurrent web requests are supported? Depends on memory and CPU cores.
  ## will be set automatically by bootstrap based on detected CPUs, or you can override
  UNICORN_WORKERS: 8

  ## Required. Discourse will not work with a bare IP number.
  DISCOURSE_HOSTNAME: {{ lookup('domain',application_id) }}

  ## Uncomment if you want the container to be started with the same
  ## hostname (-h option) as specified above (default "$hostname-$config")
  #DOCKER_USE_HOSTNAME: true

  ## on initial signup example 'user1@example.com,user2@example.com'
  DISCOURSE_DEVELOPER_EMAILS:       {{ users.administrator.email }}

  # Set Logo
  {% if service_provider.platform.logo | bool %}
  DISCOURSE_LOGO_URL:       "{{ service_provider.platform.logo  }}"
  DISCOURSE_LOGO_SMALL_URL: "{{ service_provider.platform.logo  }}"
  {% endif %}

  {% if SYSTEM_EMAIL_ENABLED | bool %}
  # SMTP ADDRESS, username, and password are required
  # WARNING the char '#' in SMTP password can cause problems!
  DISCOURSE_SMTP_ADDRESS:           {{ SYSTEM_EMAIL_HOST }}
  DISCOURSE_SMTP_PORT:              {{ SYSTEM_EMAIL_PORT }}
  DISCOURSE_SMTP_USER_NAME:         {{ users['no-reply'].email }}
  DISCOURSE_SMTP_PASSWORD:          {{ users['no-reply'].tokens['web-app-mailu'] }}
  DISCOURSE_SMTP_ENABLE_START_TLS:  {{ SYSTEM_EMAIL_START_TLS }}
  DISCOURSE_SMTP_FORCE_TLS:         {{ SYSTEM_EMAIL_TLS }}
  DISCOURSE_SMTP_DOMAIN:            {{ SYSTEM_EMAIL_DOMAIN }}
  DISCOURSE_NOTIFICATION_EMAIL:     {{ users['no-reply'].email }}
  {% endif %}

  # Database Configuration
  DISCOURSE_DB_USERNAME: {{ lookup('database', application_id, 'username') }}
  DISCOURSE_DB_PASSWORD: {{ lookup('database', application_id, 'password') }}
  DISCOURSE_DB_HOST:     {{ lookup('database', application_id, 'host') }}
  DISCOURSE_DB_NAME:     {{ lookup('database', application_id, 'name') }}

  # Redis Configuration
  DISCOURSE_REDIS_HOST: {{ DISCOURSE_REDIS_HOST }}

  ## If you added the Lets Encrypt template, uncomment below to get a free SSL certificate
  #LETSENCRYPT_ACCOUNT_EMAIL: administrator@veen.world

  ## The http or https CDN address for this Discourse instance (configured to pull)
  ## see https://meta.discourse.org/t/14857 for details
  #DISCOURSE_CDN_URL: https://discourse-cdn.example.com
  
  ## The maxmind geolocation IP address key for IP address lookup
  ## see https://meta.discourse.org/t/-/137387/23 for details
  #DISCOURSE_MAXMIND_LICENSE_KEY: 1234567890123456

{% if DISCOURSE_TLS_SELFSIGNED_ENABLED | bool %}
  CA_TRUST_CERT: {{ CA_ROOT.cert_host }}
  CA_TRUST_NAME: {{ lookup('domain',application_id) }}
{% endif %}

## The Docker container is stateless; all data is stored in /shared
volumes:
  - volume:
      host: {{ DISCOURSE_VOLUME }}
      guest: /shared
  - volume:
      host: /var/discourse/shared/standalone/log/var-log
      guest: /var/log

{% if DISCOURSE_TLS_SELFSIGNED_ENABLED | bool %}
  - volume:
      host:   {{ CA_ROOT.cert_host }}
      guest:  {{ CA_ROOT.cert_host }}
  - volume:
      host:   {{ BIN_CA_TRUST }}
      guest:  {{ BIN_CA_TRUST }}
{% endif %}

## Plugins go here
## see https://meta.discourse.org/t/19157 for details
hooks:
  after_code:
    - exec:
        cd: $home/plugins
        cmd:
{% for plugin_name, plugin_config in DISCOURSE_PLUGINS.items() %}
{% if plugin_config.enabled %}
          - git clone --depth=1 https://github.com/discourse/{{ plugin_name }}.git
{% endif %}
{% endfor %}     

{% if DISCOURSE_LDAP_ENABLED | bool %}
          - git clone --depth=1 https://github.com/jonmbake/discourse-ldap-auth.git
{% endif %}

## Any custom commands to run after building
run:
  - exec: echo "Beginning of custom commands"
  - exec: rails r "SiteSetting.force_https = {{ DISCOURSE_TLS_ENABLED | bool | string | lower }}"
{% if DISCOURSE_TLS_SELFSIGNED_ENABLED | bool %}
  - exec: {{ BIN_CA_TRUST }}
{% endif %}
  ## If you want to set the 'From' email address for your first registration, uncomment and change:
  ## After getting the first signup email, re-comment the line. It only needs to run once.
  #- exec: rails r "SiteSetting.notification_email='info@unconfigured.discourse.org'"
{% if DISCOURSE_OIDC_ENABLED | bool %}
  # Deactivate Default Login
  - exec: rails r "SiteSetting.openid_connect_verbose_logging = {{ MODE_DEBUG | bool | string | lower }}"
  - exec: rails r "SiteSetting.enable_local_logins = false"
  - exec: rails r "SiteSetting.enable_passkeys = false" # https://meta.discourse.org/t/passwordless-login-using-passkeys/285589

  - exec: rails r "SiteSetting.username_change_period = 0" # Deactivate changing of username

  # The following code is just an inspiration, how to connect with the oidc account. as long as this is not set the admini account needs to be manually connected with oidc 
  # docker exec -it {{ DISCOURSE_CONTAINER }} rails runner "user = User.find_by_email('test@infinito.nexus'); UserAuth.create(user_id: user.id, provider: 'oidc', uid: 'eindeutige_oidc_id', info: { name: user.username, email: user.email })"

  # OIDC Activation
  - exec: rails r "SiteSetting.openid_connect_enabled = true"
  - exec: rails r "SiteSetting.openid_connect_discovery_document = '{{OIDC.CLIENT.DISCOVERY_DOCUMENT}}'"
  - exec: rails r "SiteSetting.openid_connect_client_id = '{{ OIDC.CLIENT.ID }}'"         
  - exec: rails r "SiteSetting.openid_connect_client_secret = '{{ OIDC.CLIENT.SECRET }}'"     
  - exec: rails r "SiteSetting.openid_connect_rp_initiated_logout_redirect = '{{ DISCOURSE_OIDC_LOGOUT_REDIRECT_URL }}'"
  - exec: rails r "SiteSetting.openid_connect_allow_association_change = false"
  - exec: rails r "SiteSetting.openid_connect_rp_initiated_logout = true"

  # ---- FinalDestination allowlist (IMPORTANT) ----
  # Discourse blocks requests to internal/private IPs unless the host is allowlisted.
  # Extract host from discovery document URL and append to allowed_internal_hosts.
  - exec: >
      rails r "url=SiteSetting.openid_connect_discovery_document.to_s.strip;
      host=url.sub(%r{\Ahttps?://}i,'').split('/').first.to_s.strip;
      host=host.split(':').first.to_s.strip;
      list=SiteSetting.allowed_internal_hosts.to_s.split('|').map{|x| x.strip}.reject{|x| x.empty?};
      if !host.empty? && host =~ /\A[a-z0-9.-]+\z/i && !list.include?(host)
        list << host;
        SiteSetting.allowed_internal_hosts = list.join('|');
      end;
      puts \"allowed_internal_hosts=#{SiteSetting.allowed_internal_hosts}\";"

  # Clear OIDC discovery cache so the next login attempt refetches with the new allowlist
  - exec: >
      rails r "url=SiteSetting.openid_connect_discovery_document.to_s.strip;
      key=\"openid-connect-discovery-#{url}\";
      Discourse.cache.delete(key);
      puts \"deleted_cache_key=#{key}\";"

{% endif %}

  # Activate Administrator User (always yes, non-interactive)
  - exec: |
      cat <<'EOF' | rake admin:create
      {{ users.administrator.email }}
      {{ users.administrator.password }}
      {{ users.administrator.password }}
      Y
      Y
      EOF

  - exec: >
      rails r "User.find_by_email('{{ users.administrator.email }}')&.update!(username: '{{ users.administrator.username }}')"

{% if DISCOURSE_LDAP_ENABLED | bool %}
  # Enable LDAP authentication
  - exec: rails r "SiteSetting.ldap_auth_enabled = true"
  - exec: rails r "SiteSetting.ldap_sync_enabled = true"

  # LDAP connection settings
  - exec: rails r "SiteSetting.ldap_sync_host = '{{ LDAP.SERVER.DOMAIN }}'"
  - exec: rails r "SiteSetting.ldap_sync_port = {{ LDAP.SERVER.PORT }}"
  - exec: rails r "SiteSetting.ldap_encryption = 'simple_tls'"
  - exec: rails r "SiteSetting.ldap_base_dn = '{{ LDAP.DN.ROOT }}'"
  - exec: rails r "SiteSetting.ldap_bind_dn = '{{ LDAP.DN.ADMINISTRATOR.DATA }}'"
  - exec: rails r "SiteSetting.ldap_bind_password = '{{ LDAP.BIND_CREDENTIAL }}'"

  # LDAP additional configuration
  - exec: rails r "SiteSetting.ldap_user_filter = '{{ LDAP.FILTERS.USERS.LOGIN }}'"
  - exec: rails r "SiteSetting.ldap_group_base_dn = '{{ LDAP.DN.OU.GROUPS }}'"
  - exec: rails r "SiteSetting.ldap_group_member_check = 'memberUid'"

  - exec: rails r "SiteSetting.ldap_sync_period = 1"
  - exec: rails r "SiteSetting.ldap_sync_unit = 'hours'"

{% endif %}

  - exec: echo "End of custom commands"

docker_args:
  - --network={{ DISCOURSE_NETWORK }}
  - --name={{ DISCOURSE_CONTAINER }}
