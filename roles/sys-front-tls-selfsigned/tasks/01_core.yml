---
# Self-signed TLS provider (strict, SAN aware).
# This provider uses cert_plan for:
# - where the cert/key live (shared/global or per-app)
# - which SAN list is effective
#
# IMPORTANT:
# - We DO NOT create a self-signed leaf (issuer==subject), because that will always fail curl verification.
# - Instead, we create a local Root CA (sys-ca-selfsigned) and sign the leaf certificate with it.
# - The resulting chain is: leaf (app/global) signed by Root CA, and Root CA is installed into trust stores.

- name: "TLS | (self_signed) ensure local Root CA exists (for signing leaf certs)"
  ansible.builtin.include_role:
    name: sys-ca-selfsigned
  when: run_once_sys_ca_selfsigned is not defined

- name: "TLS | (self_signed) resolve via tls_resolve (strict)"
  ansible.builtin.set_fact:
    _tls: "{{ lookup('tls_resolve', application_id) }}"
  changed_when: false

- name: "TLS | (self_signed) plan certificate via cert_plan (strict)"
  ansible.builtin.set_fact:
    _cert: "{{ lookup('cert_plan', application_id) }}"
  changed_when: false

- name: "TLS | (self_signed) assert mode is self_signed"
  ansible.builtin.assert:
    that:
      - _tls.mode == 'self_signed'
      - _tls.enabled | bool
      - _cert.mode == 'self_signed'
      - _cert.enabled | bool
    fail_msg: >-
      sys-front-tls-selfsigned called for '{{ application_id }}' but resolver/plan returned
      tls.enabled={{ _tls.enabled }}, tls.mode={{ _tls.mode }}, cert.enabled={{ _cert.enabled }}, cert.mode={{ _cert.mode }}.
      Expected enabled=true, mode=self_signed.

- name: "TLS | (self_signed) compute target paths"
  ansible.builtin.set_fact:
    _ss_domain: "{{ _tls.domains.primary }}"
    _ss_san: "{{ _cert.domains.san }}"
    _ss_cert: "{{ _cert.files.cert }}"
    _ss_key: "{{ _cert.files.key }}"
    _ss_dir: "{{ _cert.files.cert | dirname }}"
    _ss_conf: "{{ (_cert.files.cert | dirname) ~ '/openssl.cnf' }}"
    _ss_csr: "{{ (_cert.files.cert | dirname) ~ '/req.csr' }}"
    _ss_cn: >-
      {{
        (_cert.scope == 'global')
        | ternary(
            (DOMAIN_PRIMARY | upper) ~ ' Global TLS',
            ((tls_selfsigned_subject.CN | default('') | length > 0)
              | ternary(tls_selfsigned_subject.CN, _tls.domains.primary))
          )
      }}
  changed_when: false

- name: "TLS | (self_signed) ensure directory exists"
  become: true
  ansible.builtin.file:
    path: "{{ _ss_dir }}"
    state: directory
    mode: "0750"

- name: "TLS | (self_signed) render openssl config (SAN aware)"
  become: true
  ansible.builtin.copy:
    dest: "{{ _ss_conf }}"
    mode: "0640"
    content: |
      [ req ]
      default_bits       = {{ tls_selfsigned_key_bits }}
      default_md         = sha256
      prompt             = no
      distinguished_name = dn
      req_extensions     = req_ext

      [ dn ]
      C  = {{ tls_selfsigned_subject.C }}
      O  = {{ tls_selfsigned_subject.O }}
      OU = {{ tls_selfsigned_subject.OU }}
      CN = {{ _ss_cn }}

      [ req_ext ]
      subjectAltName = @alt_names

      [ alt_names ]
      {% for d in _ss_san %}
      DNS.{{ loop.index }} = {{ d }}
      {% endfor %}

- name: "TLS | (self_signed) check if cert already exists"
  ansible.builtin.stat:
    path: "{{ _ss_cert }}"
  register: _ss_cert_stat
  changed_when: false

- name: "TLS | (self_signed) read existing certificate (if any)"
  ansible.builtin.command: "openssl x509 -in {{ _ss_cert }} -noout -text"
  register: _ss_cert_text
  changed_when: false
  failed_when: false
  when: _ss_cert_stat.stat.exists | default(false)

- name: "TLS | (self_signed) compute wanted/existing SAN sets"
  ansible.builtin.set_fact:
    _ss_wanted_sans: "{{ _ss_san | map('lower') | list | unique | sort }}"
    _ss_existing_sans: >-
      {{
        (
          (_ss_cert_text.stdout | default('')) |
          regex_findall('DNS:([^,\\s;]+)') |
          map('lower') | list | unique | sort
        )
        if (_ss_cert_stat.stat.exists | default(false)) else
        []
      }}
  changed_when: false

- block:
    - name: "TLS | (self_signed) remove outdated cert/key/csr if SAN drift detected"
      become: true
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ _ss_cert }}"
        - "{{ _ss_key }}"
        - "{{ _ss_csr }}"

    - name: "TLS | (self_signed) generate private key (if missing)"
      become: true
      ansible.builtin.command:
        argv:
          - openssl
          - genrsa
          - -out
          - "{{ _ss_key }}"
          - "{{ tls_selfsigned_key_bits | string }}"
      args:
        creates: "{{ _ss_key }}"

    - name: "TLS | (self_signed) generate CSR (SAN aware)"
      become: true
      ansible.builtin.command:
        argv:
          - openssl
          - req
          - -new
          - -key
          - "{{ _ss_key }}"
          - -out
          - "{{ _ss_csr }}"
          - -config
          - "{{ _ss_conf }}"
      args:
        creates: "{{ _ss_csr }}"

    - name: "TLS | (self_signed) sign CSR with local Root CA (creates CA-signed leaf cert)"
      become: true
      ansible.builtin.command:
        argv:
          - openssl
          - x509
          - -req
          - -in
          - "{{ _ss_csr }}"
          - -CA
          - "{{ CA_ROOT.cert_host }}"
          - -CAkey
          - "{{ CA_ROOT.key_host }}"
          - -CAcreateserial
          - -out
          - "{{ _ss_cert }}"
          - -days
          - "{{ tls_selfsigned_days | string }}"
          - -sha256
          - -extfile
          - "{{ _ss_conf }}"
          - -extensions
          - req_ext
      args:
        creates: "{{ _ss_cert }}"

  when: >-
      {{
        (not (_ss_cert_stat.stat.exists | default(false))) or
        ((_ss_wanted_sans | difference(_ss_existing_sans) | length) > 0)
      }}

- include_tasks: utils/once/flag.yml
