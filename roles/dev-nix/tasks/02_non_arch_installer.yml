---
# Non-Arch installer logic:
# Download the official Nix installer and its SHA256 from releases.nixos.org
# and run the daemon (multi-user) installer.

# 1) Fetch the official SHA256 from releases.nixos.org on the control node
- name: Fetch official Nix installer SHA256
  ansible.builtin.uri:
    url: "{{ dev_nix_installer_sha256_url }}"
    return_content: true
  register: dev_nix_official_sha_response
  delegate_to: localhost
  run_once: true
  become: false

- name: Set expected installer checksum from official SHA256
  ansible.builtin.set_fact:
    dev_nix_installer_sha256: >-
      {{ dev_nix_official_sha_response.content.split()[0] | trim }}
  run_once: true

# 2) Download installer script on the target and verify via checksum
- name: Download Nix installer script from official releases
  ansible.builtin.get_url:
    url: "{{ dev_nix_installer_url }}"
    dest: "{{ dev_nix_installer_dest }}"
    mode: "0755"
    # get_url will verify the checksum and fail if it does not match
    checksum: "sha256:{{ dev_nix_installer_sha256 }}"
  become: true

# 3) Locate nix binary in common paths and install only if missing
- name: Probe common nix binary paths before installation
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dev_nix_binary_candidates }}"
  register: dev_nix_binary_probe_before
  become: true

- name: Set nix binary path detected before installation
  ansible.builtin.set_fact:
    dev_nix_binary_path_before: >-
      {{
        (
          dev_nix_binary_probe_before.results
          | selectattr("stat.exists")
          | map(attribute="item")
          | list
          | first
        ) | default("", true)
      }}

- name: Read existing nixbld group entry before installer run
  ansible.builtin.getent:
    database: group
    key: nixbld
    fail_key: false
  become: true
  when: dev_nix_binary_path_before | length == 0

- name: Set build group override for Nix installer when nixbld exists
  ansible.builtin.set_fact:
    dev_nix_installer_build_group_id: "{{ ansible_facts.getent_group.nixbld[1] }}"
  when:
    - dev_nix_binary_path_before | length == 0
    - ansible_facts.getent_group is defined
    - "'nixbld' in ansible_facts.getent_group"

- name: Read existing nixbld1 user entry before installer run
  ansible.builtin.getent:
    database: passwd
    key: nixbld1
    fail_key: false
  become: true
  when: dev_nix_binary_path_before | length == 0

- name: Set first build uid override for Nix installer when nixbld1 exists
  ansible.builtin.set_fact:
    dev_nix_installer_first_build_uid: "{{ ansible_facts.getent_passwd.nixbld1[1] }}"
  when:
    - dev_nix_binary_path_before | length == 0
    - ansible_facts.getent_passwd is defined
    - "'nixbld1' in ansible_facts.getent_passwd"

- name: Run Nix installer in daemon (multi-user) mode if Nix is not installed
  ansible.builtin.shell: >
    "{{ dev_nix_installer_dest }}" --daemon
  environment: >-
    {{
      (
        (dev_nix_installer_build_group_id is defined)
        | ternary(
            {'NIX_BUILD_GROUP_ID': (dev_nix_installer_build_group_id | string)},
            {}
          )
      )
      | combine(
          (
            (dev_nix_installer_first_build_uid is defined)
            | ternary(
                {'NIX_FIRST_BUILD_UID': (dev_nix_installer_first_build_uid | string)},
                {}
              )
          )
        )
    }}
  become: true
  when: dev_nix_binary_path_before | length == 0

- name: Probe common nix binary paths after installation
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dev_nix_binary_candidates }}"
  register: dev_nix_binary_probe_after
  become: true

- name: Set nix binary path for systemd usage
  ansible.builtin.set_fact:
    dev_nix_binary_path: >-
      {{
        (
          dev_nix_binary_probe_after.results
          | selectattr("stat.exists")
          | map(attribute="item")
          | list
          | first
        ) | default("", true)
      }}

- name: Fail if nix binary is missing after installation
  ansible.builtin.fail:
    msg: >-
      Nix binary could not be found after installation.
      Checked: {{ dev_nix_binary_candidates | join(', ') }}
  when: dev_nix_binary_path | length == 0

- name: Ensure nix is reachable in PATH for systemd services
  ansible.builtin.file:
    src: "{{ dev_nix_binary_path }}"
    dest: /usr/local/bin/nix
    state: link
  become: true
  when: dev_nix_binary_path != "/usr/local/bin/nix"

# 4) Optionally drop shell snippet for Nix
- name: Optionally drop shell snippet for Nix
  ansible.builtin.copy:
    dest: "{{ dev_nix_shell_snippet_path }}"
    mode: "0644"
    content: |
      # Added by dev-nix Ansible role
      if [ -e /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh ]; then
        . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
      fi
  when: dev_nix_enable_shell_snippet | bool
  become: true

- name: Aggressively prune Nix data (GC + optimise)
  # CI/Debug cleanup to prevent huge disk usage from Nix store + old generations
  become: true
  ansible.builtin.shell: |
    set -euo pipefail
    nix_bin="{{ dev_nix_binary_path }}"
    nix_bin_dir="$(dirname "$nix_bin")"
    nix_collect="$nix_bin_dir/nix-collect-garbage"
    nix_store="$nix_bin_dir/nix-store"

    # Remove old generations for all users + root (aggressive)
    if [ -x "$nix_collect" ]; then
      "$nix_collect" -d
    else
      "$nix_bin" store gc || true
    fi

    # Additional GC pass (useful on some setups / older nix)
    if [ -x "$nix_store" ]; then
      "$nix_store" --gc || true
    else
      "$nix_bin" store gc || true
    fi

    # Deduplicate store paths to reduce disk usage (can take a bit).
    # Prefer modern CLI; fall back to nix-store on older setups.
    if ! "$nix_bin" store optimise; then
      if [ -x "$nix_store" ]; then
        "$nix_store" --optimise || true
      fi
    fi
  args:
    executable: /bin/bash
  changed_when: true
  when:
    - MODE_CLEANUP | bool
    - DOCKER_IN_CONTAINER | bool
